<!--
    References:
    https://blog.tensorflow.org/2021/11/3D-handpose.html
    https://github.com/tensorflow/tfjs-models/tree/master/hand-pose-detection/demos#upload-a-video-demo
    https://google.github.io/mediapipe/solutions/hands#palm-detection-model
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>XDP: Finger Tapping Test</title>


    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>
</head>

<body>
    <input type="file" id="videofile" name="video" accept="video/*">
    <button type="button" id="submit">Run</button>
    <div class="container" id="canvas-wrapper">
        <canvas id="output" style="display: none;"></canvas>
        <video id="video" style="display: none">
            <source id="currentVID" src="" type="video/mp4">
        </video>
    </div>
    <div id="score"></div>

    <script type="module">
        let initReadyStatus = false;
        const video = document.getElementById('video');
        const result = document.getElementById('score');
        let detector, camera, rafId, hands;

        function initLiveFeed() {
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(results => {
                result.innerHTML = JSON.stringify(results.multiHandWorldLandmarks, null, 2)
            });

            const camera = new Camera(video, {
                onFrame: async () => {
                    await hands.send({ image: video });
                },
                width: 1280,
                height: 720
            });
            camera.start();
        }

        async function updateVideo(event) {
                // Clear reference to any previous uploaded video.
                URL.revokeObjectURL(camera.video.currentSrc);
                const file = event.target.files[0];
                camera.source.src = URL.createObjectURL(file);

                // Wait for video to be loaded.
                camera.video.load();
                await new Promise((resolve) => {
                    camera.video.onloadeddata = () => {
                        resolve(video);
                    };
                });

                const videoWidth = camera.video.videoWidth;
                const videoHeight = camera.video.videoHeight;
                // Must set below two lines, otherwise video element doesn't show.
                camera.video.width = videoWidth;
                camera.video.height = videoHeight;
                // camera.canvas.width = videoWidth;
                // camera.canvas.height = videoHeight;

                result.innerHTML = 'Video is loaded.';
            }

        class Context {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('output');
                this.source = document.getElementById('currentVID');
                // this.ctx = this.canvas.getContext('2d');
                const stream = this.canvas.captureStream();
                const options = { mimeType: 'video/webm; codecs=vp9' };
                this.mediaRecorder = new MediaRecorder(stream, options);
                // this.mediaRecorder.ondataavailable = this.handleDataAvailable;
            }

            start() {
                this.mediaRecorder.start();
            }

            stop() {
                this.mediaRecorder.stop();
            }
        }

        async function runFrame() {
            if (video.paused) {
                // video has finished.
                camera.mediaRecorder.stop();
                // camera.clearCtx();
                // camera.video.style.visibility = 'visible';
                return;
            }
            // await renderResult();
            await hands.send({ image: camera.video });
            rafId = requestAnimationFrame(runFrame);
        }

        async function run() {

            camera.video.style.visibility = 'hidden';
            video.pause();
            video.currentTime = 0;
            video.play();
            camera.mediaRecorder.start();

            await new Promise((resolve) => {
                camera.video.onseeked = () => {
                    resolve(video);
                };
            });

            await runFrame();
        }

        function init() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(results => {
                result.innerHTML = JSON.stringify(results.multiHandWorldLandmarks, null, 2)
            });

            camera = new Context();

            const runButton = document.getElementById('submit');
            runButton.onclick = run;

            const uploadButton = document.getElementById('videofile');
            uploadButton.onchange = updateVideo;
        }

        init()
    </script>
</body>

</html>